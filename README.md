# Prim-s-and-Kruskal-s-Algorithm-GUI-based-Solution-Using-Java-Swing

## Project Description: </b>
    This project aims to provide an interactive graphical user interface (GUI) for visualizing popular
    graph algorithms, focusing on Minimum Spanning Tree (MST) techniques. The application allows
    users to input a graph manually or generate one randomly and then visualize how different
    algorithms solve the problem. 
    
## The project primarily demonstrates the following algorithms:</b>

### Minimum Spanning Tree Algorithms:</b>

### • Prim’s Algorithm: 
     Constructs an MST by selecting the smallest edge that expands the tree without forming a cycle.

### • Kruskal’s Algorithm:
     Builds an MST by sorting edges and adding them one by one while avoiding cycles using union-find structures. 

### Features:
    • Interactive Graph Creation:  Users can draw graphs by adding vertices and connecting them with weighted edges directly on the GUI. 
    • Algorithm Selection: Provides a menu to select and execute any of the supported algorithms. 
    • Step-by-Step Visualization: Displays each step of the algorithm in real-time, showing edge selections and path updates. 
    • Dynamic Edge/Node Highlighting: Highlights nodes and edges as they are processed, aking it easier to understand algorithm progression. 
    • Results Display: Outputs the total weight of the MST or the shortest path distance for clarity. 

## Technologies Used:
    • Java Swing: For designing the graphical interface and handling user interactions. 
    • Graphical Drawing Components: Utilizes drawLine, drawOval, and drawString methods for rendering the graph dynamically. 
    • Priority Queues and Union-Find: Efficient data structures for implementing Prim’s and Kruskal’s algorithms. 
    • Java Collections Framework: For managing adjacency lists, edge lists, and algorithmic processing. 

## Learning Outcomes: 
    • Understanding the real-world applications of graph algorithms in networking, transportation, and optimization. 
    • Gaining hands-on experience in data structures like adjacency lists, heaps, and disjoint sets. 
    • Enhancing problem-solving skills through the implementation of greedy and dynamic programming paradigms. 
    • Developing proficiency in Java GUI programming to create user-friendly, interactive applications. 

## Conclusion:</b>
    This project serves as an educational tool for students and enthusiasts to learn and visualize the working of complex graph algorithms. 
    By bridging the gap between theory and practice, it fosters a deeper understanding of algorithm design and analysis.
